---
layout: post
title: OC内存管理
category: iOS
---

## 手动内存管理

在OC使用RAC自动内存管理之前，都是使用手动内存管理的，也就是自己的。创建的对象需要自己释放，否则会造成内存泄漏，操作不当也会造成各种内存错误。



> 现在的Xcode是默认关闭手动内存管理，采用RAC的内存管理方式，所以我们需要在项目的设置中关闭RAC。
> 
> 在TARGETS中选中我们的项目，然后Build Setting -> Apple LLVM 7.0 - Language - Objective C -> Objective-C Automatic Reference Counting 设置值为No 。



##### 创建对象的过程

1. 分配内存空间，存储对象。
2. 初始化成员变量。
3. 返回对象的指针。



##### 内存管理的主要内容

1. 对象在完成创建的同时，内部会自动创建一个引用计数器retainCount，其初始值为1。引用计数器是系统判断是否回首此对象的空间的唯一依据。
2. 当retainCount为0的时候，系统会马上回收该对象。
3. 继承于NSObject类的对象都会有retain和release还有dealloc方法。
4. retain方法作用是让retainCount加1，并且调用后返回self指针。
5. release方法作用是让retainCount减1。
6. 当对象将要被销毁的时候，系统会自动调用它的dealloc方法，通知对象进行被销毁前的工作。与C++的析构函数相似。

> *内存管理原则（配对原则）：出现 alloc, retain就会配对出现一个release, autorelease*



一个简单的例子：

``` objective-c
NSString *str = [[NSString alloc]init];
[str release];
```



##### 野指针  *EXC_BAD_ACCESS*

[野指针](https://zh.wikipedia.org/wiki/迷途指针)当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。这种类型的程序错误，不容易找到问题的原因，通常会导致存储器区段错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。

简言之，对象已经被释放，对象的指针指向一个没有对象的内存空间，此时对象再被发送消息（调用）会引发野指针操作错误。如：

``` objective-c
NSString *p = [[NSString alloc] init];

    p.age = 10;

    [p release];
    // 如果确定当前作用域的对象已经不再使用，为了防止野指针操作，我们会给不再使用的指针赋值nil
    p = nil;	//防止野指针操作

    p.age = 30;
	NSLog(@"%d", p.age);
```



##### 内存泄漏

[内存泄漏](https://zh.wikipedia.org/wiki/内存泄漏)指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

严重的内存泄漏可能会造成内存溢出，也就是系统无法为程序提供足够多的内存空间的情况。



##### 手动内存管理下的类组合

这里假设一个情境，Person类拥有Car，Person具有setCar, car, drive方法。如下，Person.h文件

``` objective-c
//
//  Person.h
//

#import <Foundation/Foundation.h>
#import "Car.h"

@interface Person : NSObject
{
    Car * _car;
}

- (void)setCar:(Car *)car;
- (Car *)car;

- (void)drive;

@end
```

Person.m文件：

``` objective-c
//
//  Person.m
//

#import "Person.h"

//配对原则:new alloc retain 对应一个release,autorelease

@implementation Person

- (void)setCar:(Car *)car
{

    if (_car != car)
    {  
        //relese旧值
        [_car release];//[nil release];

        //retain新值
        _car  = [car retain];
    }

}
- (Car *)car
{
    return _car;
}

- (void)drive
{
    [_car run];
}
- (void)dealloc
{
    //目的是要保证在p对象存在的时候,car对象一定存在
    //对象p被销毁的时候,
    [_car release];
    [super dealloc];
    NSLog(@"Person 被销毁了");
}

@end

```

main.m文件：

``` objective-c
//
//  main.m
//

#import <Foundation/Foundation.h>
#import "Person.h"

int main(int argc, const char * argv[])
{

    @autoreleasepool {

         //p  1
        Person * p = [[Person alloc] init];

      // c1 1
        Car * c1 = [[Car alloc] init];
        c1.speed = 100;

       //c1 2
        [p setCar:c1];

        [p drive];

         //c1 1
        [c1 release];


        /*
        // 此情况如果Person方法没有判断是否同一个指针，否则会出现野指针操作
        [p setCar:c1];
        [p drive];
         */


       //c2 1
        Car * c2 = [[Car alloc] init];
        c2.speed = 350;

        //c2  2
        [p setCar:c2];


        [p drive];

        //c2 1
        [c2 release];


        //p 0
        [p release];

    }
    return 0;
}
```



##### 总结

手动内存管理对逻辑顺序要求很严格，谨记配对原则。

在手动内存管理的学习中，主要围绕野指针操作和内存泄露的问题研究。