---
date: 2016-01-29
layout: post
title: property 参数
category: iOS
---

截取自 [Objective-C中的@property](http://www.devtalking.com/articles/you-should-to-know-property/)

`@property` 是生命属性的语法，它可以快速方便的为实例变量创建存取器。

> 存取器(accessor) ： 指用于获取和设置实例变量的方法。用于获取实例变量值的存取器`getter`，用于设置实例变量值的方法是`setter`。



## @property的特性（参数）

`@property`有几种类型的关键字，都是有特殊作用的。我们大概分成四类，分别是：多线程相关，内存管理，存取器控制，存取器命名。



#### 多线程相关

- `atomic`（默认）：生成多线程管理代码，效率也较低，在iOS开发不常用。`atomic`意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，至少在当前的存取器上是安全的。
- `nonatomic`：`nonatomic`恰好与`atomic`相反。表示非原子的，可以被多个线程访问。它的效率比`atomic`快。但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。一般iOS开发都会使用这个。



#### 内存管理

- `assign`（默认）：`assign`用于值类型，如`int`、`float`、`double`和`NSInteger`，`CGFloat`等表示单纯的复制。还包括不存在所有权关系的对象，比如常见的delegate。
  
- `retian`：在`setter`方法中，需要对传入的对象进行引用计数加1的操作。
  
  简单来说，就是对传入的对象拥有所有权，只要对该对象拥有所有权，该对象就不会被释放。手动内存管理一般使用这个。效果如下：
  
  ``` objective-c
  -(void)setName:(NSString*)_name{  
       //首先判断是否与旧对象一致，如果不一致进行赋值。  
       //因为如果是一个对象的话，进行if内的代码会造成一个极端的情况：当此name的retain为1时，使此次的set操作让实例name提前释放，而达不到赋值目的。  
       if ( name != _name){  
            [name release];  
            name = [_name retain];  
       }  
  }
  ```
  
- `strong`：`strong`是在iOS引入ARC的时候引入的关键字，是`retain`的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。`strong`跟`retain`的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。
  
- `weak`：在`setter`方法中，需要对传入的对象不进行引用计数加1的操作。
  
  简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用`weak`声明的实例变量指向`nil`，即实例变量的值为0。
  
- `copy`：与`strong`类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身。



#### 存取器控制

- `readwrite`（默认）：`readwrite`是默认值，表示该属性同时拥有`setter`和`getter`。
- `readonly`：` readonly`表示只有`getter`没有`setter`。



#### 存取器命名

有时候为了语意更明确可能需要自定义访问器的名字：

``` objective-c
@property (nonatomic, setter = mySetter:,getter = myGetter ) NSString *name;
```

最常见的是BOOL类型，比如标识View是否隐藏的属性hidden。可以这样声明：

``` objective-c
@property (nonatomic,getter = isHidden ) BOOL hidden;
```